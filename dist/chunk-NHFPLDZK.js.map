{"version":3,"sources":["../src/core/memory-service.ts"],"sourcesContent":["import { loadConfig, type Config, type ResolvedConfig } from \"../config/index.js\";\nimport { StorageOrchestrator } from \"../storage/orchestrator.js\";\nimport { SearchEngine } from \"../search/engine.js\";\nimport type {\n  Tier,\n  Memory,\n  StoreParams,\n  StoreResult,\n  SearchParams,\n  UpdateParams,\n  ListParams,\n  SearchResponse,\n  HealthResponse,\n  ConversationLogEntry,\n  SummarizeResponse,\n  CreateMemoryRequest,\n} from \"./types.js\";\nimport { ConversationSummarizer } from \"../extraction/summarizer.js\";\n\n// ── MemoryService — Programmatic API ────────────────────────────────────\n\nexport class MemoryService {\n  private orchestrator!: StorageOrchestrator;\n  private searchEngine!: SearchEngine;\n  private summarizer: ConversationSummarizer | null = null;\n  private config!: ResolvedConfig;\n  private initialized = false;\n\n  private pendingConfig: Config | string | undefined;\n\n  constructor(config?: Config | string) {\n    this.pendingConfig = config;\n  }\n\n  async init(): Promise<void> {\n    if (this.initialized) return;\n\n    // Resolve config\n    if (typeof this.pendingConfig === \"string\") {\n      this.config = await loadConfig(this.pendingConfig);\n    } else if (this.pendingConfig) {\n      this.config = await loadConfig();\n      // Override with passed config (simplified — in production you'd deep merge)\n      if (this.pendingConfig.tier) this.config.tier = this.pendingConfig.tier;\n      if (this.pendingConfig.port) this.config.port = this.pendingConfig.port;\n    } else {\n      this.config = await loadConfig();\n    }\n\n    // Initialize orchestrator\n    this.orchestrator = new StorageOrchestrator(this.config);\n    await this.orchestrator.init();\n\n    // Initialize search engine\n    this.searchEngine = new SearchEngine(this.orchestrator);\n\n    // Initialize summarizer if extraction config available\n    if (this.config.extraction) {\n      this.summarizer = new ConversationSummarizer({\n        apiKey: this.config.extraction.apiKey,\n        baseUrl: this.config.extraction.baseUrl,\n        model: this.config.extraction.model,\n      });\n    }\n\n    this.initialized = true;\n  }\n\n  async close(): Promise<void> {\n    if (!this.initialized) return;\n    await this.orchestrator.close();\n    this.initialized = false;\n  }\n\n  // ── Memory CRUD ─────────────────────────────────────────────────────\n\n  async store(params: StoreParams): Promise<StoreResult> {\n    this.ensureInit();\n    const result = await this.orchestrator.createMemory({\n      agent_id: params.agentId,\n      scope: params.scope,\n      subject_id: params.subjectId ?? null,\n      content: params.content,\n      tags: params.tags,\n      source: params.source,\n      created_by: params.createdBy ?? null,\n      extract_entities: params.extractEntities,\n      expires_at: params.expiresAt ?? null,\n    });\n\n    return {\n      id: result.id,\n      agentId: result.agent_id,\n      scope: result.scope,\n      content: result.content,\n      entities: result.entities,\n      createdAt: result.created_at,\n      syncStatus: result.sync_status,\n    };\n  }\n\n  async get(id: string): Promise<Memory | null> {\n    this.ensureInit();\n    return this.orchestrator.sqlite.getMemory(id);\n  }\n\n  async update(id: string, params: UpdateParams): Promise<Memory | null> {\n    this.ensureInit();\n    const result = await this.orchestrator.updateMemory(id, {\n      content: params.content,\n      tags: params.tags,\n      scope: params.scope,\n      subject_id: params.subjectId,\n      expires_at: params.expiresAt,\n      extract_entities: params.extractEntities,\n    });\n    if (!result) return null;\n    return this.orchestrator.sqlite.getMemory(id);\n  }\n\n  async delete(id: string): Promise<boolean> {\n    this.ensureInit();\n    return this.orchestrator.deleteMemory(id);\n  }\n\n  async list(params?: ListParams): Promise<Memory[]> {\n    this.ensureInit();\n    return this.orchestrator.sqlite.listMemories({\n      agent_id: params?.agentId,\n      scope: params?.scope,\n      subject_id: params?.subjectId,\n      source: params?.source,\n      tags: params?.tags,\n      limit: params?.limit,\n      offset: params?.offset,\n      order: params?.order,\n    });\n  }\n\n  // ── Search ──────────────────────────────────────────────────────────\n\n  async search(params: SearchParams): Promise<SearchResponse> {\n    this.ensureInit();\n    return this.searchEngine.search({\n      agent_id: params.agentId,\n      query: params.query,\n      scopes: params.scopes,\n      subject_id: params.subjectId,\n      limit: params.limit,\n      include_graph: params.includeGraph,\n      cross_agent: params.crossAgent,\n      strategy: params.strategy,\n    });\n  }\n\n  async searchSemantic(params: SearchParams): Promise<SearchResponse> {\n    return this.search({ ...params, strategy: \"semantic\" });\n  }\n\n  async searchFulltext(params: SearchParams): Promise<SearchResponse> {\n    return this.search({ ...params, strategy: \"fulltext\" });\n  }\n\n  async searchGraph(params: SearchParams): Promise<SearchResponse> {\n    return this.search({ ...params, strategy: \"graph\" });\n  }\n\n  // ── Conversations ───────────────────────────────────────────────────\n\n  async logConversation(entry: ConversationLogEntry): Promise<void> {\n    this.ensureInit();\n    this.orchestrator.sqlite.appendConversationLog(entry);\n  }\n\n  async summarizeConversation(params: {\n    agentId: string;\n    sessionId: string;\n    userId: string;\n    channel: string;\n    messages: Array<{ role: \"user\" | \"assistant\" | \"system\"; content: string; timestamp: string }>;\n  }): Promise<SummarizeResponse | null> {\n    this.ensureInit();\n\n    if (!this.summarizer) return null;\n\n    const summary = await this.summarizer.summarize(params.messages);\n    if (!summary) return null;\n\n    const result = await this.orchestrator.createMemory({\n      agent_id: params.agentId,\n      scope: \"session\",\n      subject_id: params.userId,\n      content: summary,\n      tags: [\"conversation_summary\", params.channel, `session:${params.sessionId}`],\n      source: \"conversation_summary\",\n      created_by: params.agentId,\n      extract_entities: true,\n    });\n\n    return {\n      memory_id: result.id,\n      summary,\n      entities_extracted: result.entities,\n      relationships_created: 0,\n    };\n  }\n\n  // ── Entities ────────────────────────────────────────────────────────\n\n  async getEntity(type: string, id: string): Promise<Record<string, unknown> | null> {\n    this.ensureInit();\n    if (!this.orchestrator.age) return null;\n    const result = await this.orchestrator.age.getEntityWithRelationships(type, id);\n    return result.entity;\n  }\n\n  async listEntities(type?: string): Promise<Array<Record<string, unknown>>> {\n    this.ensureInit();\n    if (!this.orchestrator.age) return [];\n    return this.orchestrator.age.listEntities(type);\n  }\n\n  async getRelatedEntities(entityId: string, depth?: number): Promise<Array<Record<string, unknown>>> {\n    this.ensureInit();\n    if (!this.orchestrator.age) return [];\n    const results = await this.orchestrator.age.getRelatedEntities(entityId, depth);\n    return results.map((r) => r.entity);\n  }\n\n  // ── Admin ───────────────────────────────────────────────────────────\n\n  async health(): Promise<HealthResponse> {\n    this.ensureInit();\n    return this.orchestrator.healthCheck();\n  }\n\n  async retrySyncQueue(): Promise<{ processed: number; succeeded: number; failed: number }> {\n    this.ensureInit();\n    return this.orchestrator.retrySyncQueue();\n  }\n\n  async migrateMarkdown(paths: string[], agentId: string): Promise<{\n    migrated: number;\n    errors: string[];\n  }> {\n    this.ensureInit();\n    // Use the admin migration logic through the orchestrator directly\n    const fs = await import(\"node:fs\");\n    const pathLib = await import(\"node:path\");\n    let migrated = 0;\n    const errors: string[] = [];\n\n    for (const filePath of paths) {\n      try {\n        if (!fs.existsSync(filePath)) {\n          errors.push(`File not found: ${filePath}`);\n          continue;\n        }\n        const content = fs.readFileSync(filePath, \"utf-8\");\n        const req: CreateMemoryRequest = {\n          agent_id: agentId,\n          scope: \"global\",\n          content: content.trim(),\n          source: \"migration\",\n          created_by: \"migration\",\n          extract_entities: true,\n        };\n        await this.orchestrator.createMemory(req);\n        migrated++;\n      } catch (error) {\n        errors.push(`${filePath}: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n\n    return { migrated, errors };\n  }\n\n  // ── Config ──────────────────────────────────────────────────────────\n\n  get tier(): Tier {\n    return this.config.tier;\n  }\n\n  get resolvedConfig(): ResolvedConfig {\n    return this.config;\n  }\n\n  // ── Internal: expose orchestrator for server mode ───────────────────\n\n  getOrchestrator(): StorageOrchestrator {\n    this.ensureInit();\n    return this.orchestrator;\n  }\n\n  // ── Helpers ─────────────────────────────────────────────────────────\n\n  private ensureInit(): void {\n    if (!this.initialized) {\n      throw new Error(\"MemoryService not initialized. Call .init() first.\");\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AAqBO,IAAM,gBAAN,MAAoB;AAAA,EACjB;AAAA,EACA;AAAA,EACA,aAA4C;AAAA,EAC5C;AAAA,EACA,cAAc;AAAA,EAEd;AAAA,EAER,YAAY,QAA0B;AACpC,SAAK,gBAAgB;AAAA,EACvB;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI,KAAK,YAAa;AAGtB,QAAI,OAAO,KAAK,kBAAkB,UAAU;AAC1C,WAAK,SAAS,MAAM,WAAW,KAAK,aAAa;AAAA,IACnD,WAAW,KAAK,eAAe;AAC7B,WAAK,SAAS,MAAM,WAAW;AAE/B,UAAI,KAAK,cAAc,KAAM,MAAK,OAAO,OAAO,KAAK,cAAc;AACnE,UAAI,KAAK,cAAc,KAAM,MAAK,OAAO,OAAO,KAAK,cAAc;AAAA,IACrE,OAAO;AACL,WAAK,SAAS,MAAM,WAAW;AAAA,IACjC;AAGA,SAAK,eAAe,IAAI,oBAAoB,KAAK,MAAM;AACvD,UAAM,KAAK,aAAa,KAAK;AAG7B,SAAK,eAAe,IAAI,aAAa,KAAK,YAAY;AAGtD,QAAI,KAAK,OAAO,YAAY;AAC1B,WAAK,aAAa,IAAI,uBAAuB;AAAA,QAC3C,QAAQ,KAAK,OAAO,WAAW;AAAA,QAC/B,SAAS,KAAK,OAAO,WAAW;AAAA,QAChC,OAAO,KAAK,OAAO,WAAW;AAAA,MAChC,CAAC;AAAA,IACH;AAEA,SAAK,cAAc;AAAA,EACrB;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,CAAC,KAAK,YAAa;AACvB,UAAM,KAAK,aAAa,MAAM;AAC9B,SAAK,cAAc;AAAA,EACrB;AAAA;AAAA,EAIA,MAAM,MAAM,QAA2C;AACrD,SAAK,WAAW;AAChB,UAAM,SAAS,MAAM,KAAK,aAAa,aAAa;AAAA,MAClD,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO;AAAA,MACd,YAAY,OAAO,aAAa;AAAA,MAChC,SAAS,OAAO;AAAA,MAChB,MAAM,OAAO;AAAA,MACb,QAAQ,OAAO;AAAA,MACf,YAAY,OAAO,aAAa;AAAA,MAChC,kBAAkB,OAAO;AAAA,MACzB,YAAY,OAAO,aAAa;AAAA,IAClC,CAAC;AAED,WAAO;AAAA,MACL,IAAI,OAAO;AAAA,MACX,SAAS,OAAO;AAAA,MAChB,OAAO,OAAO;AAAA,MACd,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,WAAW,OAAO;AAAA,MAClB,YAAY,OAAO;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAM,IAAI,IAAoC;AAC5C,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,OAAO,UAAU,EAAE;AAAA,EAC9C;AAAA,EAEA,MAAM,OAAO,IAAY,QAA8C;AACrE,SAAK,WAAW;AAChB,UAAM,SAAS,MAAM,KAAK,aAAa,aAAa,IAAI;AAAA,MACtD,SAAS,OAAO;AAAA,MAChB,MAAM,OAAO;AAAA,MACb,OAAO,OAAO;AAAA,MACd,YAAY,OAAO;AAAA,MACnB,YAAY,OAAO;AAAA,MACnB,kBAAkB,OAAO;AAAA,IAC3B,CAAC;AACD,QAAI,CAAC,OAAQ,QAAO;AACpB,WAAO,KAAK,aAAa,OAAO,UAAU,EAAE;AAAA,EAC9C;AAAA,EAEA,MAAM,OAAO,IAA8B;AACzC,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,aAAa,EAAE;AAAA,EAC1C;AAAA,EAEA,MAAM,KAAK,QAAwC;AACjD,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,OAAO,aAAa;AAAA,MAC3C,UAAU,QAAQ;AAAA,MAClB,OAAO,QAAQ;AAAA,MACf,YAAY,QAAQ;AAAA,MACpB,QAAQ,QAAQ;AAAA,MAChB,MAAM,QAAQ;AAAA,MACd,OAAO,QAAQ;AAAA,MACf,QAAQ,QAAQ;AAAA,MAChB,OAAO,QAAQ;AAAA,IACjB,CAAC;AAAA,EACH;AAAA;AAAA,EAIA,MAAM,OAAO,QAA+C;AAC1D,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,OAAO;AAAA,MAC9B,UAAU,OAAO;AAAA,MACjB,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,MACf,YAAY,OAAO;AAAA,MACnB,OAAO,OAAO;AAAA,MACd,eAAe,OAAO;AAAA,MACtB,aAAa,OAAO;AAAA,MACpB,UAAU,OAAO;AAAA,IACnB,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,eAAe,QAA+C;AAClE,WAAO,KAAK,OAAO,EAAE,GAAG,QAAQ,UAAU,WAAW,CAAC;AAAA,EACxD;AAAA,EAEA,MAAM,eAAe,QAA+C;AAClE,WAAO,KAAK,OAAO,EAAE,GAAG,QAAQ,UAAU,WAAW,CAAC;AAAA,EACxD;AAAA,EAEA,MAAM,YAAY,QAA+C;AAC/D,WAAO,KAAK,OAAO,EAAE,GAAG,QAAQ,UAAU,QAAQ,CAAC;AAAA,EACrD;AAAA;AAAA,EAIA,MAAM,gBAAgB,OAA4C;AAChE,SAAK,WAAW;AAChB,SAAK,aAAa,OAAO,sBAAsB,KAAK;AAAA,EACtD;AAAA,EAEA,MAAM,sBAAsB,QAMU;AACpC,SAAK,WAAW;AAEhB,QAAI,CAAC,KAAK,WAAY,QAAO;AAE7B,UAAM,UAAU,MAAM,KAAK,WAAW,UAAU,OAAO,QAAQ;AAC/D,QAAI,CAAC,QAAS,QAAO;AAErB,UAAM,SAAS,MAAM,KAAK,aAAa,aAAa;AAAA,MAClD,UAAU,OAAO;AAAA,MACjB,OAAO;AAAA,MACP,YAAY,OAAO;AAAA,MACnB,SAAS;AAAA,MACT,MAAM,CAAC,wBAAwB,OAAO,SAAS,WAAW,OAAO,SAAS,EAAE;AAAA,MAC5E,QAAQ;AAAA,MACR,YAAY,OAAO;AAAA,MACnB,kBAAkB;AAAA,IACpB,CAAC;AAED,WAAO;AAAA,MACL,WAAW,OAAO;AAAA,MAClB;AAAA,MACA,oBAAoB,OAAO;AAAA,MAC3B,uBAAuB;AAAA,IACzB;AAAA,EACF;AAAA;AAAA,EAIA,MAAM,UAAU,MAAc,IAAqD;AACjF,SAAK,WAAW;AAChB,QAAI,CAAC,KAAK,aAAa,IAAK,QAAO;AACnC,UAAM,SAAS,MAAM,KAAK,aAAa,IAAI,2BAA2B,MAAM,EAAE;AAC9E,WAAO,OAAO;AAAA,EAChB;AAAA,EAEA,MAAM,aAAa,MAAwD;AACzE,SAAK,WAAW;AAChB,QAAI,CAAC,KAAK,aAAa,IAAK,QAAO,CAAC;AACpC,WAAO,KAAK,aAAa,IAAI,aAAa,IAAI;AAAA,EAChD;AAAA,EAEA,MAAM,mBAAmB,UAAkB,OAAyD;AAClG,SAAK,WAAW;AAChB,QAAI,CAAC,KAAK,aAAa,IAAK,QAAO,CAAC;AACpC,UAAM,UAAU,MAAM,KAAK,aAAa,IAAI,mBAAmB,UAAU,KAAK;AAC9E,WAAO,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM;AAAA,EACpC;AAAA;AAAA,EAIA,MAAM,SAAkC;AACtC,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,YAAY;AAAA,EACvC;AAAA,EAEA,MAAM,iBAAoF;AACxF,SAAK,WAAW;AAChB,WAAO,KAAK,aAAa,eAAe;AAAA,EAC1C;AAAA,EAEA,MAAM,gBAAgB,OAAiB,SAGpC;AACD,SAAK,WAAW;AAEhB,UAAM,KAAK,MAAM,OAAO,IAAS;AACjC,UAAM,UAAU,MAAM,OAAO,MAAW;AACxC,QAAI,WAAW;AACf,UAAM,SAAmB,CAAC;AAE1B,eAAW,YAAY,OAAO;AAC5B,UAAI;AACF,YAAI,CAAC,GAAG,WAAW,QAAQ,GAAG;AAC5B,iBAAO,KAAK,mBAAmB,QAAQ,EAAE;AACzC;AAAA,QACF;AACA,cAAM,UAAU,GAAG,aAAa,UAAU,OAAO;AACjD,cAAM,MAA2B;AAAA,UAC/B,UAAU;AAAA,UACV,OAAO;AAAA,UACP,SAAS,QAAQ,KAAK;AAAA,UACtB,QAAQ;AAAA,UACR,YAAY;AAAA,UACZ,kBAAkB;AAAA,QACpB;AACA,cAAM,KAAK,aAAa,aAAa,GAAG;AACxC;AAAA,MACF,SAAS,OAAO;AACd,eAAO,KAAK,GAAG,QAAQ,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,MACtF;AAAA,IACF;AAEA,WAAO,EAAE,UAAU,OAAO;AAAA,EAC5B;AAAA;AAAA,EAIA,IAAI,OAAa;AACf,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,IAAI,iBAAiC;AACnC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAIA,kBAAuC;AACrC,SAAK,WAAW;AAChB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAIQ,aAAmB;AACzB,QAAI,CAAC,KAAK,aAAa;AACrB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAAA,EACF;AACF;","names":[]}