"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var handler_exports = {};
__export(handler_exports, {
  createStaticHandler: () => createStaticHandler,
  errorToResponse: () => errorToResponse,
  mapCompactResponse: () => mapCompactResponse,
  mapEarlyResponse: () => mapEarlyResponse,
  mapResponse: () => mapResponse
});
module.exports = __toCommonJS(handler_exports);
var import_utils = require('../utils.js'), import_file = require('../../universal/file.js'), import_utils2 = require('../../utils.js'), import_cookies = require('../../cookies.js'), import_error = require('../../error.js');
const handleElysiaFile = (file, set = {
  headers: {}
}) => {
  const path = file.path, contentType = import_file.mime[path.slice(path.lastIndexOf(".") + 1)];
  return contentType && (set.headers["content-type"] = contentType), file.stats && set.status !== 206 && set.status !== 304 && set.status !== 412 && set.status !== 416 ? file.stats.then((stat) => {
    const size = stat.size;
    return size !== void 0 && (set.headers["content-range"] = `bytes 0-${size - 1}/${size}`, set.headers["content-length"] = size), (0, import_utils.handleFile)(file.value, set);
  }) : (0, import_utils.handleFile)(file.value, set);
}, mapResponse = (response, set, request) => {
  if ((0, import_utils2.isNotEmpty)(set.headers) || set.status !== 200 || set.cookie)
    switch ((0, import_utils.handleSet)(set), response?.constructor?.name) {
      case "String":
        return set.headers["content-type"] = "text/plain", new Response(response, set);
      case "Array":
      case "Object":
        return set.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set);
      case "ElysiaFile":
        return handleElysiaFile(response, set);
      case "File":
        return (0, import_utils.handleFile)(response, set);
      case "Blob":
        return (0, import_utils.handleFile)(response, set);
      case "ElysiaCustomStatusResponse":
        return set.status = response.code, mapResponse(
          response.response,
          set,
          request
        );
      case void 0:
        return response ? new Response(JSON.stringify(response), set) : new Response("", set);
      case "Response":
        return handleResponse(response, set, request);
      case "Error":
        return errorToResponse(response, set);
      case "Promise":
        return response.then(
          (x) => mapResponse(x, set, request)
        );
      case "Function":
        return mapResponse(response(), set, request);
      case "Number":
      case "Boolean":
        return new Response(
          response.toString(),
          set
        );
      case "Cookie":
        return response instanceof import_cookies.Cookie ? new Response(response.value, set) : new Response(response?.toString(), set);
      case "FormData":
        return new Response(response, set);
      default:
        if (response instanceof Response)
          return handleResponse(response, set, request);
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set));
        if (response instanceof Error)
          return errorToResponse(response, set);
        if (response instanceof import_error.ElysiaCustomStatusResponse)
          return set.status = response.code, mapResponse(
            response.response,
            set,
            request
          );
        if (
          // @ts-expect-error
          typeof response?.next == "function" || response instanceof ReadableStream
        )
          return handleStream(response, set, request);
        if (typeof response?.then == "function")
          return response.then(
            (x) => mapResponse(x, set)
          );
        if (typeof response?.toResponse == "function")
          return mapResponse(response.toResponse(), set);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91)
            return set.headers["Content-Type"] || (set.headers["Content-Type"] = "application/json"), new Response(
              JSON.stringify(response),
              set
            );
        }
        return new Response(response, set);
    }
  return (
    // @ts-expect-error
    typeof response?.next == "function" || response instanceof ReadableStream ? handleStream(response, set, request) : mapCompactResponse(response, request)
  );
}, mapEarlyResponse = (response, set, request) => {
  if (response != null)
    if ((0, import_utils2.isNotEmpty)(set.headers) || set.status !== 200 || set.cookie)
      switch ((0, import_utils.handleSet)(set), response?.constructor?.name) {
        case "String":
          return set.headers["content-type"] = "text/plain", new Response(response, set);
        case "Array":
        case "Object":
          return set.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set);
        case "ElysiaFile":
          return handleElysiaFile(response, set);
        case "File":
          return (0, import_utils.handleFile)(response, set);
        case "Blob":
          return (0, import_utils.handleFile)(response, set);
        case "ElysiaCustomStatusResponse":
          return set.status = response.code, mapEarlyResponse(
            response.response,
            set,
            request
          );
        case void 0:
          return response ? new Response(JSON.stringify(response), set) : void 0;
        case "Response":
          return handleResponse(response, set, request);
        case "Promise":
          return response.then(
            (x) => mapEarlyResponse(x, set)
          );
        case "Error":
          return errorToResponse(response, set);
        case "Function":
          return mapEarlyResponse(response(), set);
        case "Number":
        case "Boolean":
          return new Response(
            response.toString(),
            set
          );
        case "FormData":
          return new Response(response);
        case "Cookie":
          return response instanceof import_cookies.Cookie ? new Response(response.value, set) : new Response(response?.toString(), set);
        default:
          if (response instanceof Response)
            return handleResponse(response, set, request);
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          if (response instanceof import_error.ElysiaCustomStatusResponse)
            return set.status = response.code, mapEarlyResponse(
              response.response,
              set,
              request
            );
          if (
            // @ts-expect-error
            typeof response?.next == "function" || response instanceof ReadableStream
          )
            return handleStream(response, set, request);
          if (typeof response?.then == "function")
            return response.then(
              (x) => mapEarlyResponse(x, set)
            );
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse(response.toResponse(), set);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set.headers["Content-Type"] || (set.headers["Content-Type"] = "application/json"), new Response(
                JSON.stringify(response),
                set
              );
          }
          return new Response(response, set);
      }
    else
      switch (response?.constructor?.name) {
        case "String":
          return set.headers["content-type"] = "text/plain", new Response(response);
        case "Array":
        case "Object":
          return set.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set);
        case "ElysiaFile":
          return handleElysiaFile(response, set);
        case "File":
          return (0, import_utils.handleFile)(response, set);
        case "Blob":
          return (0, import_utils.handleFile)(response, set);
        case "ElysiaCustomStatusResponse":
          return set.status = response.code, mapEarlyResponse(
            response.response,
            set,
            request
          );
        case void 0:
          return response ? new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          }) : new Response("");
        case "Response":
          return response;
        case "Promise":
          return response.then((x) => {
            const r = mapEarlyResponse(x, set);
            if (r !== void 0) return r;
          });
        case "Error":
          return errorToResponse(response, set);
        case "Function":
          return mapCompactResponse(response(), request);
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          return response instanceof import_cookies.Cookie ? new Response(response.value, set) : new Response(response?.toString(), set);
        case "FormData":
          return new Response(response);
        default:
          if (response instanceof Response) return response;
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          if (response instanceof import_error.ElysiaCustomStatusResponse)
            return set.status = response.code, mapEarlyResponse(
              response.response,
              set,
              request
            );
          if (
            // @ts-expect-error
            typeof response?.next == "function" || response instanceof ReadableStream
          )
            return handleStream(response, set, request);
          if (typeof response?.then == "function")
            return response.then(
              (x) => mapEarlyResponse(x, set)
            );
          if (typeof response?.toResponse == "function")
            return mapEarlyResponse(response.toResponse(), set);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91)
              return set.headers["Content-Type"] || (set.headers["Content-Type"] = "application/json"), new Response(
                JSON.stringify(response),
                set
              );
          }
          return new Response(response);
      }
}, mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, {
        headers: {
          "Content-Type": "text/plain"
        }
      });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "Content-Type": "application/json"
        }
      });
    case "ElysiaFile":
      return handleElysiaFile(response);
    case "File":
      return (0, import_utils.handleFile)(response);
    case "Blob":
      return (0, import_utils.handleFile)(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(
        response.response,
        {
          status: response.code,
          headers: {}
        }
      );
    case void 0:
      return response ? new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      }) : new Response("");
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(
        (x) => mapCompactResponse(x, request)
      );
    // ? Maybe response or Blob
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response) return response;
      if (response instanceof Promise)
        return response.then(
          (x) => mapCompactResponse(x, request)
        );
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof import_error.ElysiaCustomStatusResponse)
        return mapResponse(
          response.response,
          {
            status: response.code,
            headers: {}
          }
        );
      if (
        // @ts-expect-error
        typeof response?.next == "function" || response instanceof ReadableStream
      )
        return handleStream(response, void 0, request);
      if (typeof response?.then == "function")
        return response.then(
          (x) => mapCompactResponse(x, request)
        );
      if (typeof response?.toResponse == "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        const code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
      }
      return new Response(response);
  }
}, errorToResponse = (error, set) => {
  if (typeof error?.toResponse == "function") {
    const raw = error.toResponse(), targetSet = set ?? { headers: {}, status: 200, redirect: "" }, apply = (resolved) => (resolved instanceof Response && (targetSet.status = resolved.status), mapResponse(resolved, targetSet));
    return typeof raw?.then == "function" ? raw.then(apply) : apply(raw);
  }
  return new Response(
    JSON.stringify({
      name: error?.name,
      message: error?.message,
      cause: error?.cause
    }),
    {
      status: set?.status !== 200 ? set?.status ?? 500 : 500,
      headers: set?.headers
    }
  );
}, createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle == "function") return;
  const response = mapResponse(handle, {
    headers: setHeaders
  });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
}, handleResponse = (0, import_utils.createResponseHandler)({
  mapResponse,
  mapCompactResponse
}), handleStream = (0, import_utils.createStreamHandler)({
  mapResponse,
  mapCompactResponse
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createStaticHandler,
  errorToResponse,
  mapCompactResponse,
  mapEarlyResponse,
  mapResponse
});
